Visualizing Execution Control and Data Flow
===========================================

                    August 22, 2014

The animation is driven by an execution trace generated by
the CGC forensics subsystem.  Program structure is derived
from static analysis of the executable.  Each polyhedron represents a 
program function and each vertex corresponds to a basic block 
within the function.

Execution control flow is illustrated by the line that extends
between functions and zig zags within a function.  The former
represents a call from one function to a another.  Within a
function, the line traces flow from one basic block to another.

The rectangular plane represents heap memory of the process.
As additional memory is introduced via mmap, smaller rectangles
appear, and then disappear due to a munmap.  Data flow is
represented by colored cubes.  For example, a network read
is illustrated by a stream of cubes originating at the network
(which is represented by the black sphere).  The stream flows
to the current execution point (the vertex representing the
basic block containing the network read syscall), and then
to the destination address within memory.  Similarly, a
"rep movs" instruction is illustrated by a data stream
that starts at the memory source address, flies to the vertex, and
then on to the memory destination address.

Network reads and writes to/from the stack are not yet
represented.  However, mov operations having a destination
within the heap are represented.

Data fidelity is currently limited to about 15 bytes per cube, 
(i.e., the visualization object that represents data).  Added 
fidelity reduces framerates to unacceptable levels, (at least
for the current example heartbleed dataset).  This might
be addressed by implementation optimizations.  Higher fidelity
may also be possible for other binaries, (e.g., that use smaller
amounts of memory). 


Keyboard Controls:
==================
Navigation
----------
*   Pause/Play -- space bar
*   camera home -- h
*   up/down/left/right -- w/s/a/d
*   zoom toward function -- click it
*   pan -- option / mouse
*   orbit -- option / click / mouse
*   zoom -- track wheel or two-finger (or left shift w/s)

Suspend animation (speed up playback)
--------------------------------------
*   suspend animation between data operations (toggle) -- [left shift] R
*   suspend animation between network operations -- i
*   suspend animation until next data operation -- r

Function/Memory Navigation
--------------------------
*   Go to currently called function (and pause) -- b
*   Walk call chain to calling/called function (with optional function labels) -- n/N
*   View function information -- [left shift] click 
*   View memory address -- [left shift] click (and hold)

Bookmarks and Breakpoints
=========================
Large datasets can take a while to simulate, which motivates
the keyboard shortcuts to suspend animation described above
under Keyboard Controls. You can also create bookmarks at
selected points within a simulation, and then jump to that
point in subsequent runs. A bookmarks records the entire state
of the simulation.  Creating and jumping to bookmarks is 
achieved via the menu.

Additionally, the dataset itself can be modified to add breakpoints.
A breakpoint is of the form: "break name", where 
"break_name" is any string (no spaces) that will display in the 
upper left when the breakpoint is reached.

Note that breakpoints may interfere with the precision of 
bookmarks because bookmarks are based on instruction locations
within the dataset file.  It is suggested that breakpoints only be
used to stop at a location that is to then be bookmarked.  The 
breakpoint can then be removed.

Configuration
=============
Menu options let you select the color scheme of the various 
visualization elements using RGB sliders.  These options are maintained in a 
file within the configurations directory.  Use the "save configuration"
menu option to save the current color scheme (and other choices) for future use.
Deleting the configuration.txt file reverts to default values.

The menu includes an option to change the current project, e.g., to
some other execution trace for the same, or some other, binary.

When walking call chains (using "b" and "n" as described above under
"Function Navigation"), labels describing the current fuction will appear
if the "Function Labels" menu checkbox is selected.

[esc] to quit menu or to hide a function label.

The dataset
===========
The visualization is driven by two files: combined.txt is the 
post-processed execution trace; and functionList.txt identifies
functions and basic blocks, resulting from static analysis of the
binary being visualized.  The combined.txt file is a sequence of
operations derived from an execution trace of the binary.  These
operations include network reads and writes, (derived from syscalls),
mmap/munmap, memory copies (read/write), (e.g., resulting from "rep movs"), and
execution control flow, (calls and goto's).


Heartbleed Example
==================
The proof-of-concept is the openssl server consuming a 
heartbleed exploit.  The dataset driving the example
is recorded from an openssl server initializing and
then servicing two connections, the latter of which includes
an exploit that exposes information provided by the first
session.  For exposition purposes, the example visualization
would begin at the start of the second session.  All of the
data present at the commencement of the second session is
treated as "protected", i.e., the second session should not
be able to read the content of those addresses.

Note that this heartbleed example is not entirely consistent
with a CGC PoV.  In particular, CGC services do not retain
state between sessions. This is the motivation behind treating
the start of the second session as the start of the visualization,
and using the CGC protected memory PoV as the model.  


TBD
===
The quantity bytes represented by each data object should be
configurable via the menu, (with suitable warnings since this
would invalidate existing bookmarks.)  (Add bytes-per-block to
the bookmark xml to catch mismatches).  The size of the memory
plane would then be derived from the bytes per block and the
amount of bss heap memory actually used.

Network reads/writes to/from the stack.  Represent the stack,
e.g., a nebulous pile might work since we need not 
distinguish between stack locations for taint flow.
